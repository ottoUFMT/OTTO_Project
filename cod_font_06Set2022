#include "Arduino.h"
#include "SoftwareSerial.h"
#include "DFRobotDFPlayerMini.h"
#include "LedControl.h"
#include <SPI.h> // comunicação SPI (possivelmente defasado. muito capaz de necessario para a camera)
#include <MFRC522.h> // RFID
#include <IRremote.h> // infravermelho 
#include <avr/wdt.h> // watchdog
#include <Servo.h> // servo
#include <Keypad.h> // Biblioteca do matriz numerica
//fon

int x=0; // variavel testes
boolean play_state; // estado do modulo dfplayer

Servo FL, FR; //servos pé
Servo AL, AR; //servos braços

//Pinos Reset e SS módulo MFRC522
#define SS_PIN 9  //pino RFID
#define RST_PIN 8 //pino RFID

MFRC522 mfrc522(SS_PIN, RST_PIN);   //RFID
MFRC522::MIFARE_Key key;            //RFID
SoftwareSerial mySoftwareSerial(10, 11); // RX, TX  //pino DFPLAYER
LedControl lc = LedControl(22, 24, 26, 1); // DIN, CS, CLK, NRDEV pino LED

int posx=0;                 //posição motor
  
#define LeftFoot 4 // left foot pin
#define RightFoot 5 // right foot pin

#define PIN_AL 6 // left arm pin
#define PIN_AR 7 // right arm pin

const byte LINHAS = 2; // n. Linhas do teclado
const byte COLUNAS = 5; // n. Colunas do teclado

const char TECLAS_MATRIZ[LINHAS][COLUNAS] = { // Matriz de caracteres (mapeamento do teclado)
  {'0','1','2','3','4'},
  {'5','6','7','8','9'}
};

const byte PINOS_LINHAS[LINHAS] = {38,40}; // Pinos de conexao com as linhas do teclado
const byte PINOS_COLUNAS[COLUNAS] = {42,44,46,48,49}; // Pinos de conexao com as colunas do teclado

Keypad teclado_personalizado = Keypad(makeKeymap(TECLAS_MATRIZ), PINOS_LINHAS, PINOS_COLUNAS, LINHAS, COLUNAS); // Inicia teclado



int RECV_PIN = 30;   // pino infravermelho
IRrecv irrecv(RECV_PIN);     //infravermelho
decode_results results;     // resultados infravermelho

DFRobotDFPlayerMini myDFPlayer; 
String Song = "";     //string recebida
int play = 0;         //numero musica
int estadobotao=0;    //matriz botão ligada ou nao
int estadoliga=0;     //robo ligado ou nao
float armazenavalor;  //valor hexadecimal do IR

void attachF(){       //atach pes
FL.attach(LeftFoot);
FR.attach(RightFoot);
}

void attachA(){       //attach braços
AL.attach(PIN_AL);
AR.attach(PIN_AR);
}
//varias emoçoes de led
byte full[] = {
  B11111111,
  B11111111,
  B11111111,
  B11111111,
  B11111111,
  B11111111,
  B11111111,
  B11111111
};

byte heart[] = {
  B01110000 ,
  B11111000 ,
  B01111100 ,
  B00111110 ,
  B00111110 ,
  B01111100 ,
  B11111000 ,
  B01110000
};

byte Sorriso[] = {
B01111000,
B01101100,
B01100110,
B01100110,
B01100110,
B01100110,
B01101100,
B01111000

};

byte Triste[] = {
  B00000110,
B00011000,
B00110000,
B00100000,
B00100000,
B00110000,
B00011000,
B00000110
};

byte Barulho[] = {
B00111100,
B01111100,
B11111100,
B11111100,
B11111100,
B11111100,
B01111100,
B00111100
};
byte cansado[] = {
B00001000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000
};
byte Surpreso[] = {
  B00111100,
  B01111110,
  B11111111,
  B11111111,
  B11111111,
  B11111111,
  B01111110,
  B00111100
};
byte medo[] = {
B00010000,
B00001000,
B00010000,
B00001000,
B00010000,
B00001000,
B00010000,
B00001000
};
byte raiva[] = {
B00011110,
B00101001,
B01001001,
B01001010,
B01001010,
B01001001,
B00101001,
B00011110
};byte enjoo[] = {
B01000100,
B00111000,
B00010000,
B00010000,
B00010000,
B00010000,
B00111000,
B01000100
};
byte sono0[] = {
B00010000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000,
B00010000
};
byte sono1[] = {
  B00000000,
  B00000000,
  B00011000,
  B00100100,
  B00100100,
  B00011000,
  B00000000,
  B00000000
};
byte sono2[] = {
  B00111100,
  B01000010,
  B11000011,
  B10000001,
  B10000001,
  B11000011,
  B01000010,
  B00111100
};
byte vergonha[] = {
B00010000,
B00011000,
B00001000,
B00000100,
B00000100,
B00001000,
B00011000,
B00010000
};

byte neutro[] = {
  B00010000,
  B00010000,
  B00010000,
  B00010000,
  B00010000,
  B00010000,
  B00010000,
  B00010000
};
byte vazio[] = {
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000
};

void setup() {
  lc.shutdown(0, false);
  lc.setIntensity(0, 7);
  lc.clearDisplay(0);
  irrecv.enableIRIn(); // Inicializa o receptor IR  
  avazio();
  //Comunicacao serial com o modulo
  mySoftwareSerial.begin(9600);
  //Inicializa a serial do Arduino

  Serial.begin(115200);   //Inicia a serial
  SPI.begin();      //Inicia  SPI bus
  mfrc522.PCD_Init();   //Inicia MFRC522
Serial.println("A");
  //Prepara chave - padrao de fabrica = FFFFFFFFFFFFh
  for (byte i = 0; i < 6; i++) key.keyByte[i] = 0xFF;

  //Verifica se o modulo esta respondendo e se o
  //cartao SD foi encontrado
  Serial.println(F("Inicializando modulo DFPlayer Mini (3~5 segundos)"));
  if (!myDFPlayer.begin(mySoftwareSerial))
  {
    Serial.println(F("Nao inicializado:"));
    Serial.println(F("1.Cheque as conexoes do DFPlayer Mini"));
    Serial.println(F("2.Insira um cartao SD"));
    while (true);
  }
  Serial.println();
  Serial.println(F("Modulo DFPlayer Mini inicializado!"));

  //Definicoes iniciais
  myDFPlayer.setTimeOut(500); //Timeout serial 500ms
  myDFPlayer.volume(30); //Volume 5
  myDFPlayer.EQ(0); //Equalizacao normal

  //Mostra o menu de comandos
  Serial.println();
  Serial.print("Numero de arquivos no cartao SD: ");
  Serial.println(myDFPlayer.readFileCounts(DFPLAYER_DEVICE_SD));
  //wdt_enable(WDTO_8S);
}

//parada
void emerg(){
  
    if (irrecv.decode(&results))  
  {  Serial.println(results.value, HEX); 
    armazenavalor = (results.value);  
  if(armazenavalor == 0xFFB04F){
        parar();
 }
  irrecv.resume(); //Le o próximo valor   
  }
    }
//funçao que faz a matriz ter os bites das emoçoes
void afull() {
  for (int i = 0; i < 8; i++)  {
    lc.setRow(0, i, full[i]);
  }
}
void aHEART() {
  for (int i = 0; i < 8; i++)  {
    lc.setRow(0, i, heart[i]);
  }
}

void aSorriso() {
  for (int i = 0; i < 8; i++)  {
    lc.setRow(0, i, Sorriso[i]);
  }
}

void aTriste() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, Triste[i]);
  }
}

void abarulho() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, Barulho[i]);
  }
}
void aneutro() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, neutro[i]);
  }
}
void avazio() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, vazio[i]);
  }
}
void aSurpreso() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, Surpreso[i]);
  }
}
void amedo() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, medo[i]);
  }
}
void acansado() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, cansado[i]);
  }
}
void araiva() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, raiva[i]);
  }
}
void asono() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, sono0[i]);
  }  
    delay(700);
  for (int i = 0; i < 8; i++) {lc.setRow(0, i, sono1[i]);
  } delay(700);
   
  for (int i = 0; i < 8; i++) { lc.setRow(0, i, sono2[i]);    
  }  delay(700);
  
  for (int i = 0; i < 8; i++) {lc.setRow(0, i, sono1[i]);
  } delay(700);
  
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, sono0[i]);
  }  delay(1000);
  }

void avergonha() {
  for (int i = 0; i < 8; i++) {
    lc.setRow(0, i, vergonha[i]);
  }
}

//função detach todos servos
void detachall(){
  AR.detach();
  AL.detach();
  FR.detach();
  FL.detach();
}


// funçoes mov de motores
void braco1(){
  for (posx = 90; posx<= 180; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(8);                       // waits 15 ms for the servo to reach the position
  }
  }
  

void aceno(){
  AR.attach(PIN_AR);
  delay(50);
  //  emerg();
 for (posx = 90; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(13);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 0; posx<= 30; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(12);                       // waits 15 ms for the servo to reach the position
  }
  //  emerg();
  for (posx = 30; posx>= 0; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(12);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 0; posx<= 30; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(12); 
  }
  //  emerg();
  for (posx = 30; posx>= 0; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(12);
  }
    for (posx = 0; posx<= 90; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);
  }
   // emerg();
  detachall();
}
void acertar(){
  //som acertar
  attachA();
  delay(50);
  braco1();
    emerg();
for (posx = 180; posx>= 150; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 150; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position    
  }
    emerg();
for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position    
  }
    emerg();
  for (posx = 180; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(8);                       // waits 15 ms for the servo to reach the position
  } 
  detachall();
}
void errar(){
  attachA();
  delay(50);
  //som errar
    emerg();
  for (posx = 90; posx>= 0; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(8);                       // waits 15 ms for the servo to reach the position
  }
  delay(2000);
  
    emerg();
    for (posx = 0; posx<= 90; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(8);                       // waits 15 ms for the servo to reach the position
    } 
  detachall();
}
void mraiva(){
  attachA();
  delay(50);
  braco1();
  for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position    
  }
    emerg();
  for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position    
  }
    emerg();
  for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 0; posx<= 90; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(180-posx);
    delay(10);                       // waits 15 ms for the servo to reach the position    
  }  
    emerg();
  detachall();
}

void perna1(){
  for (posx = 90; posx<= 180; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 180; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
}
void perna2(){
  for (posx = 90; posx>= 0; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 0; posx<= 90; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
}
void perna1b(){
  for (posx = 90; posx<= 180; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  
    emerg();
    for (posx = 180; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
}
void perna2b(){
  for (posx = 90; posx>= 0; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 0; posx<= 90; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
}

void perna3(){
  FR.attach(RightFoot);
  delay(10);
  for (posx = 90; posx<= 150; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  AL.attach(PIN_AL);
  delay(20);
  for (posx = 90; posx<= 170; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
      delay(7);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 170; posx>= 90; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(7);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 180; posx>= 90; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  FR.detach();
  AL.detach();
}
void perna4(){
  FL.attach(LeftFoot);
  delay(10);
  for (posx = 90; posx>= 30; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  AR.attach(PIN_AR);
  delay(10);
  for (posx = 90; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
      delay(7);                       // waits 15 ms for the servo to reach the position
  }
  for (posx = 60; posx<= 90; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(7);                       // waits 15 ms for the servo to reach the position
  }
  
    emerg();
 for (posx = 0; posx<= 90; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  AR.detach();
  FL.detach();
}

void dancap1(){
  attachF();
  delay(100);    
  emerg();
 perna1();
 emerg();
 perna2();
 emerg();
 perna1();
 emerg();
 perna2();
 emerg();
 
 delay(100);
 
}
void dancap1b(){
  attachF();
  delay(100);
 perna1b();
 emerg();
 perna2b();
 emerg();
 perna1b();
 emerg();
 perna2b();
 emerg();
 delay(100);
}
void dancap2(){
    attachA();
  delay(50);  
  for (posx = 90; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
    for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
    for (posx = 180; posx>= 0; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
    for (posx = 0; posx<= 180; posx+= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(7);                       // waits 15 ms for the servo to reach the position
  }for (posx = 180; posx>= 90; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    AR.write(posx);
    delay(7);                       // waits 15 ms for the servo to reach the position
  }
  detachall();
}

void dancap3(){
detachall();
delay(30);
perna3();
delay(20);
perna3();
delay(20);
perna4();
delay(20);
perna4();
delay(20);
perna3();
delay(20);
//perna4();
//delay(20);
}
void parar(){
  wdt_enable(WDTO_15MS);
  delay(20);
  detachall();
  estadoliga=0;
  estadobotao=0;
  myDFPlayer.pause();
      delay(10);
      Serial.println("parou");
}

void dancaN(){
  attachF();
  for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
    for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  } 
    emerg();
    for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    FL.write(posx-30);
    delay(10);                       // waits 15 ms for the servo to reach the position
  }for (posx = 120; posx>= 90; posx-= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
}

void TapF(){
  AL.attach(PIN_AL);
  for (posx = 90; posx<= 180; posx+= 3) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(7);                       // waits 15 ms for the servo to reach the position
  }
  FR.attach(RightFoot);
  for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  delay(300);
  for (posx = 120; posx>= 90; posx-= 3) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    for (posx = 90; posx<= 120; posx+= 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
    emerg();
  delay(300);
  for (posx = 120; posx>= 90; posx-= 3) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    FR.write(posx);              // tell servo to go to position in variable 'pos'
    delay(10);                       // waits 15 ms for the servo to reach the position
  }
  
  for (posx = 180; posx>= 90; posx-= 2) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    AL.write(posx);              // tell servo to go to position in variable 'pos'
    delay(7);                       // waits 15 ms for the servo to reach the position
  }
  detachall();
}


void modo_leitura()
{
  //Aguarda cartao
  //while ( ! mfrc522.PICC_IsNewCardPresent())
 // {
 // Serial.println("fon");
 // }
  if ( ! mfrc522.PICC_ReadCardSerial())
  {
    
    Serial.print("B");
    return;
  }
  //Mostra UID na serial

  //Obtem os dados do setor 0, bloco 1 
  byte sector         = 0;
  byte blockAddr      = 1;
  byte trailerBlock   = 3;
  byte status;
  byte buffer[18];
  byte size = sizeof(buffer);


  //Autenticacao usando chave A
  status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A,
                                    trailerBlock, &key, &(mfrc522.uid));
  if (status != MFRC522::STATUS_OK)
  {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }
  status = mfrc522.MIFARE_Read(blockAddr, buffer, &size);
  if (status != MFRC522::STATUS_OK)
  {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
  }
  //Mostra os dados do sobrenome no Serial Monitor e LCD
  Song = "";
  for (byte i = 0; i < 16; i++)
  {
    char sound = char(buffer[i]);
    String rc(sound);
    Song += rc;
  }
  play = Song.toInt();
  
  if (play > 10)
  {
    Serial.println();
    Serial.print("Reproduzindo musica: ");
    Serial.print(Song);
    myDFPlayer.play(play);
  }
  if (play < 11)
  {
    switch (play) {
  case 1:
    myDFPlayer.play(play);
   aHEART();
   delay(1000);
   aneutro();
    break;
  case 2:
    myDFPlayer.play(play);
  abarulho();
     delay(1000);
   aneutro();
    break;
   case 3:
    myDFPlayer.play(play);
  acansado();
     delay(1000);
   aneutro();
    break;
      case 4:
    myDFPlayer.play(play);
  amedo();
     delay(1000);
   aneutro();
    break;
      case 5:
    myDFPlayer.play(play);
  araiva();
  mraiva();
   aneutro();
    break;
      case 6:
    myDFPlayer.play(play);
  asono();
  
   aneutro();
    break;
      case 7:
    myDFPlayer.play(play);
  avergonha();
     delay(1000);
   aneutro();
    break;
      case 8:
    myDFPlayer.play(play);
  acansado();
     delay(1000);
   aneutro();
    break;
      case 9:
    myDFPlayer.play(play);
  aSorriso();
  acertar();
  
     delay(500);
   aneutro();
    break;
      case 10:
    myDFPlayer.play(play);
  aTriste();
  errar();
     delay(500);
   aneutro();
    break;
}
}
//x=1;
delay(1000);
//  while (x==1){
//  delay(250);          // wait for sensors to stabilize

//    x=0;
//    Serial.print("C");
//  }
//} 

  Serial.println();
  // Halt PICC
  mfrc522.PICC_HaltA();
  // Stop encryption on PCD
  mfrc522.PCD_StopCrypto1();
//    myDFPlayer.play(play);

    Serial.print("D");
    return;
}

void loop()
{
  
}
  if (irrecv.decode(&results))  
  {  
    Serial.println(results.value, HEX); 
    armazenavalor = (results.value);  
  if(armazenavalor == 0xFFB04F){
  if(estadoliga==0){
    
    play=182;
    myDFPlayer.play(play);
    aHEART();
    aceno();
    estadoliga=1;
    
    delay(1000);
    aneutro();
    
  }
  else{
    play=181;
    myDFPlayer.play(play);
        aceno();
        delay(1500);
        avazio();
        Serial.println("desliga robo");
        parar();
      }
  }
  if( estadoliga==1){      
    if (armazenavalor == 0xFF18E7) //Verifica se a tecla ^ foi acionada  
    {  
    play=183;
    myDFPlayer.play(play);
      acertar();
      Serial.println("Acertou");
    }  
    if (armazenavalor == 0xFF4AB5) //Verifica se a tecla V foi acionada  
    {  
    play=184;
    myDFPlayer.play(play);
      errar();
      Serial.println("Errou");
    }  
    if (armazenavalor == 0xFF5AA5) //Verifica se a tecla > foi acionada  
    {  
      myDFPlayer.volumeUp();
      Serial.println("Volume+");
    }  
    if (armazenavalor == 0xFF10EF) //Verifica se a tecla < foi acionada  
    {  
      myDFPlayer.volumeDown();
      Serial.println("Volume-");
    }  
    if (armazenavalor == 0xFF02FD) //Verifica se a tecla 5 foi acionada  
    {  
    play=185;
    myDFPlayer.play(play);
  detachall();
  delay(50);
 dancaN();
  detachall();
  delay(50);
 dancap1b();
  detachall();
  delay(50);
 TapF();
 delay(20);
 detachall();
 dancap2();
  detachall();
  delay(20);
  
 dancap3();
  detachall();
  delay(20);
      Serial.println("Dança");
    }  
    if (armazenavalor == 0xFF6897) //Verifica se a tecla * foi acionada  
    {  
      if(estadobotao==0){
        Serial.println("liga botões");
        estadobotao=1;
      }
      else{
        Serial.println("desliga botões");
        estadobotao=0;
      }
    }
    
    }
    
  Serial.println(estadoliga);
   irrecv.resume(); //Le o próximo valor   
  delay(500);

  }

  
  char leitura_teclas = teclado_personalizado.getKey(); // Atribui a variavel a leitura do teclado

  if (leitura_teclas) { // Se alguma tecla foi pressionada
    Serial.println(leitura_teclas); // Imprime a tecla pressionada na porta serial
  }
  if(estadobotao==1){
  if(leitura_teclas=='1'){
    play=172;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='2'){
    play=173;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='3'){
    play=174;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='4'){
    play=175;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='5'){
    play=176;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='6'){
    play=177;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='7'){
    AL.write(130);
    play=178;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='8'){
    AL.write(20);
    play=179;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='9'){
        FL.write(130);

    play=180;
    myDFPlayer.play(play);
  }
  if(leitura_teclas=='0'){
        FL.write(20);
    play=171;
    myDFPlayer.play(play);
  }}

  //se o estado esta ligado, não há nenhum som tocando e há cartão novo:
  if(estadoliga==1){
  play_state = digitalRead(32);
  if(play_state == HIGH){
  if(mfrc522.PICC_IsNewCardPresent()){
  modo_leitura();
 }}}
  wdt_reset();
  //}

//181 = despedida
//182 = introdução
//183 = aplauso
//184 = erro (ultimo)
//185  = musica
